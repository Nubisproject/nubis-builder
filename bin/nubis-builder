#!/bin/bash

# Globals
packer_options=""

# Print some help
usage() {
   if [[ $# -gt 0 ]]; then
      echo "ERROR: $*"
      echo
   fi

   echo "Usage: $0 <build|test> --builder-prefix <path to nubis-builder checkout> --project-path <path to project> [--json-file <path to extra json files>] [--packer-option <option>] [--keep-json] [--verbose]"
   echo
   echo "This script is the nubis build tool which will take a local check out of a project and"
   echo "subject it to the build processes that have been developed for the nubis project."
   echo
   echo "It requires that bin/ is in your $PATH, for now."
   exit 1
}

# Print messages
message_print(){
   local exit_after=0

   case "$1" in
      OK)
         code="0"
         color="0;32"
         ;;
      WARNING)
         code="1"
         color="0;33"
         ;;
      CRITICAL)
         code="2"
         color="1;31"
         exit_code=1
         ;;
   esac

   if [[ -t 1 ]]; then
      echo -e "\033[${color}m${2}\033[0m"
   else
      echo "${1}: ${2}"
   fi

   if [[ -n "$3" ]]; then
      echo
      echo "$3"
      echo
   fi

   if [[ $exit_code -gt 0 ]]; then
      if [[ ${keep_json:-0} -eq 1 ]]; then
         sanitize_json
      fi

      if [[ "$json_merged_file" ]]; then
         verbose_print "Removing temporary file $json_merged_file"   
         rm -f $json_merged_file
      fi

      if [[ "$packer_template_file" ]]; then
         verbose_print "Removing temporary file $packer_template_file"   
         rm -f $packer_template_file
      fi

      exit $exit_code
   fi
}

# Print verbose messages
verbose_print(){
   if [[ ${verbose:-0} -eq 1 ]]; then
      lines=$(wc -l <<< "$1")

      (if [[ $lines -gt 1 ]]; then
         echo -e "\033[1;37m${1}\033[0m"
      else
         echo "$1"
      fi) | awk "{ if (NR == 1){ printf \"$(date +%s): %s\n\", \$0 } else { printf \"                      %s\n\", \$0 } }"
   fi
}

if [[ $# -lt 1 ]]; then
   usage
fi

# We call this every time we find a json file we want to read in, the jq command below will
# merge all elements
json_merge_file(){
   local new_json_merged_file

   new_json_merged_file=$(mktemp /tmp/json_merged_file.XXXXXXXX)
   if [[ "$json_merged_file" ]]; then
      verbose_print "Merging $1 and $json_merged_file into $new_json_merged_file"
      jq -s 'def flatten: reduce .[] as $i([]; if $i | type == "array" then . + ($i | flatten) else . + [$i] end); [.[] | to_entries] | flatten | reduce .[] as $dot ({}; .[$dot.key] += $dot.value)' $json_merged_file $1 > $new_json_merged_file

      if [[ $? -ne 0 ]]; then
         rm -f $new_json_merged_file
         message_print CRITICAL "jq failed"
      fi

      rm -f $json_merged_file
   else
      cat $1 >> $new_json_merged_file
   fi

   json_merged_file=$new_json_merged_file
}

# Sanitize json file after an error, hopefully this will help prevent accidental credential disclosure
# by leaving files in /tmp
sanitize_json(){
   # Give the user a more sensible path name which is related to the project we're building
   project_name=$(jq --raw-output '"\(.variables.project_name)"' < $project_path/nubis/packer/project.json)
   sanitized_json_file=$(mktemp /tmp/${project_name}.json.XXXXXXXX)

   jq ".variables.aws_access_key = \"<REDACTED>\" | \
       .variables.aws_secret_key = \"<REDACTED>\" | \
       .variables.aws_account_id = \"<REDACTED>\" | \
       .variables.aws_x509_cert_path = \"<REDACTED>\" | \
       .variables.aws_x509_key_path = \"<REDACTED>\"" < $json_merged_file > $sanitized_json_file

   echo "Sanitized json file created as $sanitized_json_file"
}

# Remove json bits that we don't want to feed into packer and put it into a new file
generate_packer_template(){
   packer_template_file=$(mktemp /tmp/packer_templaer.json.XXXXXXXX)
   verbose_print "Generating packer template $packer_template_file"

   # We add a meta parameter 'order' to the provisioners to ensure write our order, as packer
   # executes them chronologically.
   #
   # We also add the array 'builders' into the variables that dictates which builders
   # we load, and packer doesn't consume that either.
   jq '. + { "provisioners": .provisioners | sort_by(.order | tonumber) } |
       del(.provisioners[] | .order) |
       del(.variables.builders)' < $json_merged_file > $packer_template_file

   if [[ $? -ne 0 ]]; then
      message_print CRITICAL "generate_packer_template: jq failed"
   fi
}

# Verify that our version number is unique, and that it's not younger than the latest published version.
verify_version(){
   local automatic_version_verify

   automatic_version_verify=$(jq --raw-output '"\(.variables.automatic_version_verify)"' < $json_merged_file)
   if [[ ${automatic_version_verify:-0} -eq "1" ]]; then
      verbose_print "Verifying project version is unique"
      nubis-verify-version --project-file $json_merged_file
      if [[ $? -ne 0 ]]; then
         message_print CRITICAL "nubis-verify-version had non-zero exit status"
      fi
   else
      verbose_print "Skipping version verification"
   fi
}

# Bump project version automatically, if enabled
bump_version(){
   local automatic_version_bump

   automatic_version_bump=$(jq --raw-output '"\(.variables.automatic_version_bump)"' < $json_merged_file)
   if [[ ${automatic_version_bump:-null} -ne "null" ]]; then
      verbose_print "Running nubis-bump-version --project-file $project_path/nubis/packer/project.json --build $nubis_bump_version_args"
      nubis-bump-version --project-file $project_path/nubis/packer/project.json --minor

      if [[ $? -ne 0 ]]; then
         message_print CRITICAL "nubis-bump-version had non-zero exit status"
      fi

      json_merge_file $project_path/nubis/packer/project.json
   else
      verbose_print "Skipping automatic project build number bump because automatic_version_bump is set to disabled"
   fi
}

build(){
   while [[ ! -z "$1" ]]; do
      case "$1" in
         --builder-prefix)
            if [[ "$2" ]]; then
               if [[ -d "$2" ]]; then
                  builder_prefix="$2"
               else
                  message_print CRITICAL "$2 doesn't exist or is not a directory"
               fi
            else
               message_print CRITICAL "$0: $1: missing parameter"
            fi
            shift
            ;;
         --project-path)
            if [[ "$2" ]]; then
               if [[ -d "$2" ]]; then
                  project_path="$2"
               else
                  message_print CRITICAL "$2 doesn't exist or is not a directory"
               fi
            else
               message_print CRITICAL "$0: $1: missing parameter"
            fi
            shift
            ;;
         --json-file)
            if [[ "$2" ]]; then
               if [[ -f "$2" ]]; then
                  json_files="$json_files $2"
               else
                  message_print CRITICAL "$2 doesn't exist or is not a file"
               fi
            else
               message_print CRITICAL "$0: $1: missing parameter"
            fi
            shift
            ;;
         --packer-option)
            packer_options="$packer_options $2"
            ;;
         --keep-json)
            keep_json=1
            ;;
         --verbose)
            verbose=1
            ;;
         *)
            usage "Invalid option $1"
       esac
       shift
   done

   if [[ ! "$builder_prefix" ]]; then
      usage "--builder-prefix is a required parameter"
   fi

   if [[ ! "$project_path" ]]; then
      usage "--builder-prefix is a required parameter"
   fi

   # We have build tools in $builder_prefix/bin that we need to use
   PATH=$PATH:$builder_prefix/bin

   # Merge together all the various json files
   for i in $builder_prefix/secrets/*.json ${project_path}/nubis/packer/*.json $json_files; do
      if [[ -f $i ]]; then
         verbose_print "Loading $i"
         json_merge_file $i
      fi
   done

   # Import builders
   for builder in $(jq --raw-output '"\(.variables.builders[])"' < $json_merged_file); do
      if [[ -f ${builder_prefix}/packer/builders/${builder}.json ]]; then
         verbose_print "Loading builder $builder from ${builder_prefix}/packer/builders"
         json_merge_file ${builder_prefix}/packer/builders/${builder}.json
      elif [[ -f ${project_path}/nubis/packer/${builder}.json ]]; then
         verbose_print "Loading builder $builder from ${project_path}/nubis/packer"
         json_merge_file ${project_path}/nubis/packer/${builder}.json
      else
         message_print CRITICAL "Builder $builder was specified, but $builder_prefix/packer/builders/$builder.json doesn't exist"
      fi
   done

   # Build a list of source AMI IDs for our build
   project_source_ami_project=$(jq --raw-output '"\(.variables.project_source_ami_project)"' < $json_merged_file)
   if [[ ${project_source_ami_project:-null} == null ]]; then
      message_print CRITICAL "project_source_ami_project is a required json variable"
   fi

   project_source_ami_version=$(jq --raw-output '"\(.variables.project_source_ami_version)"' < $json_merged_file)
   if [[ "$project_source_ami_project" == "base" ]]; then
      verbose_print "Base image build detected"

      if [[ "${project_source_ami_version:-null}" != "null" ]]; then
         message_print CRITICAL "source ami version pinning is not supported when building base images"
      else
         # Special AMI selection case for the base image, we don't have a project we can reference so
         # we hard code some stuff in generate-base-ami-ids.
         aws_base_ami_json=$(mktemp /tmp/aws_base_ami_json.XXXXXXXX)
         verbose_print "Running generate-base-ami-ids --json-file $json_merged_file --output-file $aws_base_ami_json"
         generate-base-ami-ids --json-file $json_merged_file --output-file $aws_base_ami_json

         if [[ $? -ne 0 ]]; then
            message_print CRITICAL "generate-base-ami-ids failed"
         fi

         verbose_print "Base AMI IDs generated, merging"
         json_merge_file $aws_base_ami_json

         verbose_print "Removing temporary file $aws_base_ami_json"
         rm -f $aws_base_ami_json
      fi
   else
      if [[ "$project_source_ami_version" != "null" ]]; then
         generate_source_ami_ids_args="--project-version $project_source_ami_version"
      fi

      aws_source_ami_json=$(mktemp /tmp/aws_source_ami_json.XXXXXXXX)
      verbose_print "Running generate-source-ami-ids --json-file $json_merged_file --output-file $aws_source_ami_json"
      generate-source-ami-ids --project-name $project_source_ami_project --json-file $json_merged_file --output-file $aws_source_ami_json $generate_source_ami_ids_args

      if [[ $? -ne 0 ]]; then
         message_print CRITICAL "generate-source-ami-ids failed"
      fi

      verbose_print "Source AMI IDs generated, merging"
      json_merge_file $aws_source_ami_json

      verbose_print "Removing temporary file $aws_base_ami_json"
      rm -f $aws_source_ami_json
   fi

   # Kick off librarian-puppet, if it's enabled in json.
   verbose_print "Searching to see if librarian_puppet_puppetfile has been set"
   librarian_puppet_puppetfile=$(jq --raw-output '"\(.variables.librarian_puppet_puppetfile)"' < $json_merged_file)
   if [[ "${librarian_puppet_puppetfile:-null}" != "null" ]]; then
      hash librarian-puppet 2>/dev/null || message_print CRITICAL "Please install librarian-puppet to use this build tool. https://github.com/rodjek/librarian-puppet"

      if [[ -f "$project_path/$librarian_puppet_puppetfile" ]]; then
         verbose_print "librarian_puppet_puppetfile is set to $librarian_puppet_puppetfile and is valid inside $project_path"

         verbose_print "Running nubis-librarian-puppet --project-path $project_path --json-file $json_merged_file"
         nubis-librarian-puppet --librarian-puppetfile $project_path/$librarian_puppet_puppetfile --librarian-puppet-path ${project_path}/nubis/nubis-puppet --json-file $json_merged_file
         if [[ $? -ne 0 ]]; then
            message_print CRITICAL "nubis-librarian-puppet failed"
         fi
      else
         message_print CRITICAL "librarian_puppet_puppetfile points to $librarian_puppet_puppetfile but it does not exist or is not a file"
      fi

      # Merge in puppet-masterless.json, which adds the masterless provisioner to use the puppet code pulled in by librarian-puppet
      json_merge_file $builder_prefix/packer/provisioners/puppet-masterless.json
   else
      verbose_print "librarian_puppet_puppetfile is not set"
   fi

   # Bump the version minor
   bump_version

   # Verify the version is newer than already published AMIs
   verify_version

   # Generate packer's template file
   generate_packer_template

   # Run packer
   verbose_print "Running packer build $json_merged_file"
   cd $project_path && packer build $packer_options $packer_template_file
   if [[ $? -ne 0 ]]; then
      message_print CRITICAL "packer failed"
   fi

   if [[ "$json_merged_file" ]]; then
      verbose_print "Cleaning up temporary files $json_merged_file and $packer_template_file"
      rm -f $json_merged_file $packer_template_file
   fi
}

hash jq 2>/dev/null || message_print CRITICAL "Please install jq to use this build tool. https://github.com/stedolan/jq"
hash aws 2>/dev/null || message_print CRITICAL "Please install the AWS CLI API to use this build tool. https://aws.amazon.com/cli/"
hash packer 2>/dev/null || message_print CRITICAL "Please install packer to use this build tool. https://packer.io/"

case "$1" in
   build)
      shift 1
      build $@
      ;;
   test)
      message_print CRITICAL "Testing is not yet supported"
      ;;
   *)
      usage "Invalid option: $1"
      exit 1
      ;;
esac
