#!/bin/bash

# Print some help
usage() {
   if [[ $# -gt 0 ]]; then
      echo "ERROR: $*"
      echo
   fi

   echo "Usage: $0 <build|test|clean> --project-path <path to project> [--verbose] [<parameters>]"
   echo
   echo "This script is the nubis build tool which will take a local check out of a project and"
   echo "subject it to the build processes that have been developed for the nubis project."
   echo
   echo "It requires that bin/ is in your $PATH, for now."
   exit 1
}

# Print messages
message_print(){
   local exit_after=0

   case "$1" in
      OK)
         code="0"
         color="0;32"
         ;;
      WARNING)
         code="1"
         color="0;33"
         ;;
      CRITICAL)
         code="2"
         color="1;31"
         exit_code=1
         ;;
   esac

   if [[ -t 1 ]]; then
      echo -e "\033[${color}m${2}\033[0m"
   else
      echo "${1}: ${2}"
   fi

   if [[ -n "$3" ]]; then
      echo
      echo "$3"
      echo
   fi

   if [[ $exit_code -gt 0 ]]; then
      if [[ "$json_merged_file" ]]; then
         verbose_print "Removing temporary file $json_merged_file"   
         rm -f $json_merged_file
      fi

      exit $exit_code
   fi
}

# Print verbose messages
verbose_print(){
   if [[ ${verbose:-0} -eq 1 ]]; then
      lines=$(wc -l <<< "$1")

      (if [[ $lines -gt 1 ]]; then
         echo -e "\033[1;37m${1}\033[0m"
      else
         echo "$1"
      fi) | awk "{ if (NR == 1){ printf \"$(date +%s): %s\n\", \$0 } else { printf \"                      %s\n\", \$0 } }"
   fi
}

if [[ $# -lt 1 ]]; then
   usage
fi

json_merge_file(){
   local new_json_merged_file

   if [[ $# -lt 1 ]]; then
      message_print CRITICAL "json_merge_metadata argument count mismatch, expected 1"
   fi

   new_json_merged_file=$(mktemp /tmp/json_merged_file.XXXXXXXX)
   verbose_print "Created new json metadata file $new_json_merged_file"

   if [[ "$json_merged_file" ]]; then
      verbose_print "Merging $json_merged_file and $1 with jq"
      jq -s 'def flatten: reduce .[] as $i([]; if $i | type == "array" then . + ($i | flatten) else . + [$i] end); [.[] | to_entries] | flatten | reduce .[] as $dot ({}; .[$dot.key] += $dot.value)' $json_merged_file $1 > $new_json_merged_file

      if [[ $? -ne 0 ]]; then
         message_print CRITICAL "jq failed"
      fi
      verbose_print "Merge successful"

      verbose_print "Cleaning up old json file $json_merged_file"
      rm -f $json_merged_file
   else
      cat $1 >> $new_json_merged_file
   fi

   json_merged_file=$new_json_merged_file
}

build(){
   while [[ ! -z "$1" ]]; do
      case "$1" in
         --project-path)
            if [[ "$2" ]]; then
               if [[ -d "$2" ]]; then
                  project_path="$2"
               else
                  message_print CRITICAL "$2 doesn't exist or is not a directory"
               fi
            else
               message_print CRITICAL "$0: $1: missing parameter"
            fi
            shift
            ;;
         --json-file)
            if [[ "$2" ]]; then
               if [[ -f "$2" ]]; then
                  json_files="$json_files $2"
               else
                  message_print CRITICAL "$2 doesn't exist or is not a file"
               fi
            else
               message_print CRITICAL "$0: $1: missing parameter"
            fi
            shift
            ;;
         --verbose)
            verbose=1
            ;;
         *)
            usage "Invalid option $1"
       esac
       shift
   done

   # Merge together all the various json files
   verbose_print "Searching for json files to include..."
   for i in secrets/*.json ${project_path}/nubis/packer/*.json; do
      verbose_print "Testing if $i is a valid file"
      if [[ -f $i ]]; then
         verbose_print "$i is a valid file, merging"
         json_merge_file $i
      else
         verbose_print "$i is not a valid file"
      fi
   done

   # Import all builders for now, we can add some granularity here later.
   for i in packer/builders/*.json; do
      verbose_print "Running json_merge_file $i"
      json_merge_file $i
   done

   # Build a list of source AMI IDs for our build
   project_source_ami_project=$(jq --raw-output '"\(.variables.project_source_ami_project)"' < $json_merged_file)
   if [[ ! "$project_source_ami_project" ]]; then
      message_print CRITICAL "project_source_ami_project is a required json variable"
   fi

   project_source_ami_version=$(jq --raw-output '"\(.variables.project_source_ami_version)"' < $json_merged_file)
   if [[ "$project_source_ami_project" == "base" ]]; then
      verbose_print "Base image build detected"

      if [[ "${project_source_ami_version:-null}" != "null" ]]; then
         message_print CRITICAL "source ami version pinning is not supported when building base images"
      else
         # Special AMI selection case for the base image, we don't have a project we can reference so
         # we hard code some stuff in generate-base-ami-ids.
         aws_base_ami_json=$(mktemp /tmp/aws_base_ami_json.XXXXXXXX)
         verbose_print "Running generate-base-ami-ids --json-file $json_merged_file --output-file $aws_base_ami_json"
         generate-base-ami-ids --json-file $json_merged_file --output-file $aws_base_ami_json

         if [[ $? -ne 0 ]]; then
            message_print CRITICAL "generate-base-ami-ids failed"
         fi

         verbose_print "Base AMI IDs generated, merging"
         json_merge_file $aws_base_ami_json

         verbose_print "Removing temporary file $aws_base_ami_json"
         rm -f $aws_base_ami_json
      fi
   else
      if [[ "$project_source_ami_version" != "null" ]]; then
         # version pinning is true
         message_print CRITICAL "non-base build targets currently unsupported"
      else
         # version pinning is false
         message_print CRITICAL "non-base build targets currently unsupported"
      fi

      # Some other AMI selection logic
   fi

   # Kick off librarian-puppet, if it's enabled in json.
   verbose_print "Searching to see if librarian_puppet_puppetfile has been set"
   librarian_puppet_puppetfile=$(jq --raw-output '"\(.variables.librarian_puppet_puppetfile)"' < $json_merged_file)
   if [[ "${librarian_puppet_puppetfile:-null}" != "null" ]]; then
      if [[ -f "$project_path/$librarian_puppet_puppetfile" ]]; then
         verbose_print "librarian_puppet_puppetfile is set to $librarian_puppet_puppetfile and is valid inside $project_path"

         verbose_print "Running nubis-librarian-puppet --project-path $project_path --json-file $json_merged_file"
         nubis-librarian-puppet --librarian-puppetfile $project_path/$librarian_puppet_puppetfile --librarian-puppet-path ${project_path}/nubis/nubis-puppet --json-file $json_merged_file
         if [[ $? -ne 0 ]]; then
            message_print CRITICAL "nubis-librarian-puppet failed"
         fi
      else
         message_print CRITICAL "librarian_puppet_puppetfile points to $librarian_puppet_puppetfile but it does not exist or is not a file"
      fi

      # Merge in puppet-masterless.json, which adds the masterless provisioner to use the puppet code pulled in by librarian-puppet
      json_merge_file packer/provisioners/puppet-masterless.json
   else
      verbose_print "librarian_puppet_puppetfile is not set"
   fi

   # Bump version
   verbose_print "Checking to see if automatic_version_bump is enabled"
   automatic_version_bump=$(jq --raw-output '"\(.variables.automatic_version_bump)"' < $json_merged_file)
   if [[ ${automatic_version_bump:-null} -ne "null" ]]; then
      verbose_print "automatic_version_bump is enabled"
      verbose_print "Checking to see if skip_collision_detection is enabled"
      skip_collision_detection=$(jq --raw-output '"\(.variables.skip_collision_detection)"' < $json_merged_file)
      if [[ ${skip_collision_detection:-0} -eq "1" ]]; then
         verbose_print "skip_collision_detection is on"
         nubis_bump_version_args="--skip-collision-detection"
      fi

      verbose_print "Running nubis-bump-version --project-file $project_path/nubis/packer/project.json --build $nubis_bump_version_args"
      nubis-bump-version --project-file $project_path/nubis/packer/project.json --build $nubis_bump_version_args
   else
      verbose_print "automatic_version_bump is disabled"
   fi

   # Run packer
   verbose_print "Running packer build $json_merged_file"
   cd $project_path && packer build $json_merged_file

   verbose_print "Removing temporary file $json_merged_file"   
   rm -f $json_merged_file
}

hash jq 2>/dev/null || message_print CRITICAL "Please install jq to use this build tool. https://github.com/stedolan/jq"
hash aws 2>/dev/null || message_print CRITICAL "Please install the AWS CLI API to use this build tool. https://aws.amazon.com/cli/"
hash packer 2>/dev/null || message_print CRITICAL "Please install packer to use this build tool. https://packer.io/"
hash librarian-puppet 2>/dev/null || message_print CRITICAL "Please install librarian-puppet to use this build tool. https://github.com/rodjek/librarian-puppet"

case "$1" in
   build)
      shift 1
      build $@
      ;;
   *)
      echo "$0: Invalid option: $1"
      exit 1
      ;;
esac
